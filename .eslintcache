[{"/Users/michaelhatch/Code/bananagrams-helper/src/index.js":"1","/Users/michaelhatch/Code/bananagrams-helper/src/solver.js":"2","/Users/michaelhatch/Code/bananagrams-helper/src/dictionary.js":"3","/Users/michaelhatch/Code/bananagrams-helper/src/state.js":"4","/Users/michaelhatch/Code/bananagrams-helper/src/trie.js":"5"},{"size":2010,"mtime":1607200788647,"results":"6","hashOfConfig":"7"},{"size":3604,"mtime":1607200792016,"results":"8","hashOfConfig":"7"},{"size":805,"mtime":1607200963604,"results":"9","hashOfConfig":"7"},{"size":3186,"mtime":1607200814531,"results":"10","hashOfConfig":"7"},{"size":331,"mtime":1607200817717,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14","usedDeprecatedRules":"15"},"now93f",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"15"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},"/Users/michaelhatch/Code/bananagrams-helper/src/index.js",["26"],"import \"./styles.css\";\nimport React, { useState } from \"React\";\nimport ReactDOM from \"react-dom\";\nimport { createSolver } from \"./solver\";\n\nconst App = () => {\n  const [blacklist, setBlacklist] = useState(\"\");\n  const [board, setBoard] = useState([[]]);\n  const [letters, setLetters] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [tray, setTray] = useState(\"\");\n\n  const solver = createSolver();\n\n  const updateBlacklistAndSolve = (e) => {\n    const newBlacklist = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setBlacklist(newBlacklist);\n    solver.solve(letters, newBlacklist);\n  };\n  const updateLettersAndSolve = (e) => {\n    const newLetters = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setLetters(newLetters);\n    solver.solve(newLetters, blacklist);\n  };\n\n  solver.onUpdate(({ tray, message, board }) => {\n    setTray(tray);\n    setMessage(message);\n    setBoard(board);\n  });\n\n  return (\n    <div>\n      <div class=\"header\">\n        <h1>Bananagrams Solver</h1>\n      </div>\n      <div class=\"letterbox\">\n        <input type=\"text\" placeholder=\"yourtileshere\" value={letters} onInput={updateLettersAndSolve} />\n      </div>\n      <div class=\"controls\">\n        <div>\n          <label>Word Blacklist</label>\n          <small>(Comma-separated)</small>\n        </div>\n        <div>\n          <input type=\"text\" value={blacklist} onInput={updateBlacklistAndSolve} />\n        </div>\n      </div>\n      <div class=\"boardbox\">\n        <div class=\"board\">\n          {board.map((row) => (\n            <div class=\"row\">\n              {row.map((cell) => (\n                <div class=\"cell\" class={cell === \" \" ? \"empty\" : \"\"}>\n                  {cell}\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div class=\"tray\">{tray}</div>\n      <div class=\"message\">{message}</div>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"app\")\n);\n",["27","28"],"/Users/michaelhatch/Code/bananagrams-helper/src/solver.js",[],"/Users/michaelhatch/Code/bananagrams-helper/src/dictionary.js",["29"],"/Users/michaelhatch/Code/bananagrams-helper/src/state.js",["30","31","32"],"class State {\n  constructor(tray, board, columns) {\n    this.board = board || new Map();\n    this.columns = columns || 1;\n    this.tray = tray;\n  }\n\n  getBoard() {\n    const numRows = Math.max(...this.board.keys());\n    let numColumns = 0;\n    return Array(numRows)\n      .fill(true)\n      .map((_, rowIndex) => {\n        const row = this.board.get(rowIndex + 1);\n        if (row) {\n          const rowColumns = Math.max(numColumns, ...row.keys());\n          if (rowColumns > numColumns) {\n            numColumns = rowColumns;\n          }\n          const columns = Array(numColumns).fill(\" \");\n          row.forEach((col, colIndex) => {\n            columns[colIndex - 1] = col;\n          });\n          return columns;\n        } else {\n          return Array(numColumns).fill(\" \");\n        }\n      });\n  }\n\n  getColSegments() {\n    /*\n    return something like [{\n      col index,\n      row where `tiles` starts,\n      how many blank rows up (or 0 for no blockers),\n      how many blank rows down (or 0 for no blockers),\n      tiles: \"c-t\"\n    }, ...]\n    */\n  }\n\n  getRowSegments() {\n    /*\n    return something like [{\n      row index,\n      col where `tiles` starts,\n      how many blank cols left (or 0 for no blockers),\n      how many blank cols right (or 0 for no blockers),\n      tiles: \"c-t\"\n    }, ...]\n    */\n  }\n\n  getStateAfterPlacement({ row, col, down, word }, dictionary) {\n    const boardClone = this.board; // TODO: create a deep clone\n    let columnsClone = this.columns;\n    let trayClone = this.tray;\n    let error = false;\n    // TODO: handle negative row and col values\n    // TODO: add rows as needed to fit \"down\" words\n    if (down) {\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const originalValue = row.get(col);\n        const row = boardClone.get(row + index);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          // TODO: check the whole row using `dictionary.isAWord` to make sure we aren't creating any invalid words\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        row.set(col, letter);\n      });\n    } else {\n      const row = boardClone.get(row);\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const colPlusIndex = col + index;\n        const originalValue = row.get(colPlusIndex);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          // TODO: check the whole column using `dictionary.isAWord` to make sure we aren't creating any invalid words\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        row.set(colPlusIndex, letter);\n        if (colPlusIndex > columnsClone) {\n          columnsClone = colPlusIndex;\n        }\n      });\n    }\n    if (error) {\n      return false;\n    }\n    return new State(trayClone, boardClone, columnsClone);\n  }\n\n  getTray() {\n    return this.tray;\n  }\n\n  isSolution() {\n    return !this.tray;\n  }\n}\n\nexport const createState = (tray) => new State(tray);\n","/Users/michaelhatch/Code/bananagrams-helper/src/trie.js",["33"],"class Trie {\n  constructor() {\n    const compressed = \"TODO: compressed trie\";\n    // TODO: uncompress `compressed`\n    // to get array of words: Object.keys(efrt.unpack(packd));\n    this.trie = new Map();\n    // TODO: populate `this.trie`\n  }\n\n  getMap() {\n    return this.trie;\n  }\n}\n\nexport const createTrie = () => new Trie();\n",{"ruleId":"34","severity":1,"message":"35","line":54,"column":35,"nodeType":"36","endLine":54,"endColumn":70},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":11,"column":11,"nodeType":"43","messageId":"44","endLine":11,"endColumn":16},{"ruleId":"45","severity":1,"message":"46","line":67,"column":31,"nodeType":"43","messageId":"47","endLine":67,"endColumn":34},{"ruleId":"45","severity":1,"message":"46","line":68,"column":36,"nodeType":"43","messageId":"47","endLine":68,"endColumn":39},{"ruleId":"45","severity":1,"message":"46","line":81,"column":34,"nodeType":"43","messageId":"47","endLine":81,"endColumn":37},{"ruleId":"41","severity":1,"message":"48","line":3,"column":11,"nodeType":"43","messageId":"44","endLine":3,"endColumn":21},"react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","no-native-reassign",["49"],"no-negated-in-lhs",["50"],"no-unused-vars","'words' is assigned a value but never used.","Identifier","unusedVar","no-use-before-define","'row' was used before it was defined.","usedBeforeDefined","'compressed' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]