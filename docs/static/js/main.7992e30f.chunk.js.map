{"version":3,"sources":["state.js","assets/words.txt","dictionary.js","index.js","solver.js"],"names":["State","tray","board","columns","this","Map","numRows","Math","max","keys","numColumns","Array","fill","map","_","rowIndex","row","get","rowColumns","forEach","col","colIndex","dictionary","down","word","boardClone","rowCols","rowKey","cols","colKey","set","columnsClone","trayClone","error","split","letter","index","tileRow","originalValue","lastSpaceWasEmpty","cell","result","trim","rowWord","isAWord","replace","colPlusIndex","colWord","Dictionary","trie","fetch","wordsTxt","slice","then","response","a","text","wordsStr","nodesArr","pattern","RegExp","syms","symCount","some","node","m","exec","fromAlphaCode","nodes","length","val","Object","assign","readyCallback","can","temp","includes","s","seq","undefined","indexOf","n","places","range","pow","i","d","charCodeAt","segments","patternMap","placements","Set","words","getWordsFromTray","segment","add","test","crawl","pref","console","log","Error","canBeMadeFromTray","matches","str","ref","have","indexFromRef","key","has","dnode","chars","push","callback","solver","boardStates","running","onReady","boardState","getTray","getSegments","possiblePlacements","getPossiblePlacements","possibleNextStates","possiblePlacement","stateAfterPlacement","getStateAfterPlacement","updateCallback","message","config","getBoard","blacklist","emptyBoard","createState","getPossibleNextStates","clear","size","iteration","solution","possibleNextState","isSolution","toString","update","Symbol","tryBoardState","splitKey","splitKeyLen","parseInt","join","setPossibleNextStates","lastIndex","App","useState","setBlacklist","setBoard","letters","setLetters","setMessage","ready","setReady","setTray","onUpdate","className","type","placeholder","value","onInput","e","newLetters","target","toLowerCase","solve","disabled","newBlacklist","cellIndex","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7992e30f.chunk.js","sourcesContent":["class State {\n  constructor(tray, board, columns) {\n    this.board = board || new Map();\n    this.columns = columns || 1;\n    this.tray = tray;\n  }\n\n  getBoard() {\n    const numRows = Math.max(...this.board.keys());\n    let numColumns = 0;\n    return Array(numRows)\n      .fill(true)\n      .map((_, rowIndex) => {\n        const row = this.board.get(rowIndex + 1);\n        if (row) {\n          const rowColumns = Math.max(numColumns, ...row.keys());\n          if (rowColumns > numColumns) {\n            numColumns = rowColumns;\n          }\n          const columns = Array(numColumns).fill(\" \");\n          row.forEach((col, colIndex) => {\n            columns[colIndex - 1] = col;\n          });\n          return columns;\n        } else {\n          return Array(numColumns).fill(\" \");\n        }\n      });\n  }\n\n  getSegments() {\n    /* TODO: return something like...\n    Set([{\n      row: the row index of the first tile in `tiles`,\n      col: the column index of the first file in `tiles`,\n      down: whether the segment is part of a row or column (down is true if column),\n      tiles: the tiles in this segment (\"-\" for whitespace),\n      pre: how much whitespace before the tiles is available,\n      post: how much whitespace after the tiles is available,\n      pattern: a regex pattern to make searching word sets fast\n    }])\n    */\n  }\n\n  getStateAfterPlacement({ row, col, down, word }, dictionary) {\n    const boardClone = new Map();\n    this.board.forEach((rowCols, rowKey) => {\n      const cols = new Map();\n      rowCols.forEach((col, colKey) => {\n        cols.set(colKey, col);\n      });\n      boardClone.set(rowKey, cols);\n    });\n    let columnsClone = this.columns;\n    let trayClone = this.tray;\n    let error = false;\n\n    // TODO: handle negative row and col values\n    // TODO: add rows as needed to fit \"down\" words\n\n    if (down) {\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const tileRow = boardClone.get(row + index);\n        const originalValue = tileRow.get(col);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          let lastSpaceWasEmpty = false;\n          const rowWords = Array(this.columns)\n            .fill(true)\n            .map((_, index) => {\n              const cell = tileRow.get(index + 1);\n              if (cell) {\n                if (lastSpaceWasEmpty) {\n                  lastSpaceWasEmpty = false;\n                }\n                return cell;\n              }\n\n              let result = \" \";\n              if (lastSpaceWasEmpty) {\n                result = \"\";\n              } else {\n                lastSpaceWasEmpty = true;\n              }\n              return result;\n            })\n            .trim()\n            .split(\" \");\n          rowWords.forEach((rowWord) => {\n            if (!dictionary.isAWord(rowWord)) {\n              error = true;\n            }\n          });\n          if (error) {\n            return;\n          }\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        tileRow.set(col, letter);\n      });\n    } else {\n      const tileRow = boardClone.get(row);\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const colPlusIndex = col + index;\n        const originalValue = tileRow.get(colPlusIndex);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          const numRows = Math.max(...this.board.keys());\n          let lastSpaceWasEmpty = false;\n          const colWords = Array(numRows)\n            .fill(true)\n            .map((_, index) => {\n              const tileRow = this.board.get(index + 1);\n              const cell = tileRow.get(colPlusIndex);\n              if (cell) {\n                if (lastSpaceWasEmpty) {\n                  lastSpaceWasEmpty = false;\n                }\n                return cell;\n              }\n\n              let result = \" \";\n              if (lastSpaceWasEmpty) {\n                result = \"\";\n              } else {\n                lastSpaceWasEmpty = true;\n              }\n              return result;\n            })\n            .trim()\n            .split(\" \");\n          colWords.forEach((colWord) => {\n            if (!dictionary.isAWord(colWord)) {\n              error = true;\n            }\n          });\n          if (error) {\n            return;\n          }\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        tileRow.set(colPlusIndex, letter);\n        if (colPlusIndex > columnsClone) {\n          columnsClone = colPlusIndex;\n        }\n      });\n    }\n    if (error) {\n      return false;\n    }\n    return new State(trayClone, boardClone, columnsClone);\n  }\n\n  getTray() {\n    return this.tray;\n  }\n\n  isSolution() {\n    return !this.tray;\n  }\n}\n\nexport const createState = (tray) => new State(tray);\n","export default __webpack_public_path__ + \"static/media/words.cc212d38.txt\";","import wordsTxt from \"./assets/words.txt\";\n\nclass Dictionary {\n  constructor() {\n    this.trie = {};\n    fetch(wordsTxt.slice(1)).then(async (response) => {\n      const wordsStr = await response.text();\n      const nodesArr = wordsStr.split(\";\");\n      const pattern = new RegExp(\"([0-9A-Z]+):([0-9A-Z]+)\");\n      const syms = new Map();\n      let symCount = 0;\n\n      nodesArr.some((node, index) => {\n        const m = pattern.exec(node);\n        if (!m) {\n          symCount = index;\n          return true;\n        }\n        syms.set(this.fromAlphaCode(m[1]), this.fromAlphaCode(m[2]));\n        return false;\n      });\n\n      const nodes = new Map(\n        nodesArr.slice(symCount, nodesArr.length).map((val, index) => {\n          return [index, val];\n        })\n      );\n\n      Object.assign(this.trie, { nodes, syms, symCount });\n      \n      this.readyCallback();\n    });\n  }\n\n  canBeMadeFromTray(tray, word) {\n    let can = true;\n    let temp = tray;\n    word.split(\"\").forEach((letter) => {\n      if (temp.includes(letter)) {\n        temp = temp.replace(letter, \"\");\n      } else {\n        can = false;\n      }\n    });\n    return can;\n  }\n\n  fromAlphaCode(s) {\n    const seq = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    if (seq[s] !== undefined) {\n      return seq.indexOf(s);\n    }\n\n    const BASE = 36;\n    let n = 0;\n    let places = 1;\n    let range = BASE;\n    let pow = 1;\n\n    while (places < s.length) {\n      n += range;\n      places++;\n      range *= BASE;\n    }\n\n    for (let i = s.length - 1; i >= 0; i--) {\n      let d = s.charCodeAt(i) - 48;\n      if (d > 10) {\n        d -= 7;\n      }\n      n += d * pow;\n      pow *= BASE;\n    }\n    return n;\n  }\n\n  getPossiblePlacements(tray, segments) {\n    const patternMap = new Map();\n    const placements = new Set();\n    const words = this.getWordsFromTray(tray);\n    \n    segments.forEach((segment) => {\n      const segments = patternMap.get(segment.pattern);\n      if (!segments) {\n        patternMap.set(segment.pattern, new Set([segment]));\n      } else {\n        segments.add(segment);\n      }\n    });\n\n    words.forEach((word) => {\n      const patterns = patternMap.keys();\n      patterns.forEach((pattern) => {\n        if (pattern.test(word)) {\n          const segments = patternMap.get(pattern);\n          segments.forEach((segment) => {\n            // TODO: find possible placements for it within the segment\n            // TODO: placements.add({ row, col, down, word });\n          });\n        }\n      });\n    });\n\n    return placements;\n  }\n\n  getWordsFromTray(tray) {\n    const words = new Set();\n    const crawl = (index, pref) => {\n      let node = this.trie.nodes.get(index);\n      \n      // TODO: FIX\n      if (!node) {\n        console.log(`!node`);\n        console.log(`index => ${index}`); // => undefined (shouldn't be)\n        console.log(this.trie.nodes);\n        throw new Error(\"temp for debugging\");\n      }\n      \n      if (node[0] === \"!\") {\n        if (this.canBeMadeFromTray(tray, pref)) {\n          words.add(pref);\n        }\n        node = node.slice(1);\n      }\n      const matches = node.split(/([A-Z0-9,]+)/g);\n      for (let i = 0; i < matches.length; i += 2) {\n        const str = matches[i];\n        if (!str) {\n          continue;\n        }\n        const ref = matches[i + 1];\n        const have = pref + str;\n        if (ref === \",\" || ref === undefined) {\n          if (this.canBeMadeFromTray(tray, have)) {\n            words.add(have);\n          }\n          continue;\n        }\n        crawl(this.indexFromRef(ref, index), have);\n      }\n    };\n    crawl(0, \"\");\n    return words;\n  }\n\n  has(trie, key) {\n    return !!trie && (key.length > 1 ? this.has(trie.get(key[0]), key.slice(1)) : trie.has(key));\n  }\n\n  indexFromRef(ref, index) {\n    const dnode = this.fromAlphaCode(ref);\n    if (dnode < this.trie.symCount) {\n      return this.trie.syms.get(dnode);\n    }\n    return index + dnode + 1 - this.trie.symCount;\n  }\n\n  isAWord(str) {\n    const chars = str.split(\"\");\n    chars.push(\"_\");\n    return this.has(this.trie, chars);\n  }\n  \n  onReady(callback) {\n    this.readyCallback = callback;\n  }\n}\n\nexport const createDictionary = () => new Dictionary();\n","import \"./assets/styles.css\";\nimport React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createSolver } from \"./solver\";\n\nconst solver = createSolver();\n\nconst App = () => {\n  const [blacklist, setBlacklist] = useState(\"\");\n  const [board, setBoard] = useState([[]]);\n  const [letters, setLetters] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [ready, setReady] = useState(false);\n  const [tray, setTray] = useState(\"\");\n\n  const updateBlacklistAndSolve = (e) => {\n    const newBlacklist = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setBlacklist(newBlacklist);\n    solver.solve(letters, newBlacklist);\n  };\n  const updateLettersAndSolve = (e) => {\n    const newLetters = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setLetters(newLetters);\n    solver.solve(newLetters, blacklist);\n  };\n  \n  solver.onReady(() => {\n    setReady(true);\n  });\n\n  solver.onUpdate(({ tray, message, board }) => {\n    setTray(tray);\n    setMessage(message);\n    setBoard(board);\n  });\n\n  return (\n    <div>\n      <div className=\"header\">\n        <h1>Bananagrams Helper</h1>\n      </div>\n      <div className=\"letterbox\">\n        <input type=\"text\" placeholder=\"yourtileshere\" value={letters} onInput={updateLettersAndSolve} disabled={!ready} />\n      </div>\n      <div className=\"controls\">\n        <div>\n          <label>Word Blacklist</label>\n          <small>(Comma-separated)</small>\n        </div>\n        <div>\n          <input type=\"text\" value={blacklist} onInput={updateBlacklistAndSolve} disabled={!ready} />\n        </div>\n      </div>\n      <div className=\"boardbox\">\n        <div className=\"board\">\n          {board.map((row, rowIndex) => (\n            <div key={rowIndex} className=\"row\">\n              {row.map((cell, cellIndex) => (\n                <div key={cellIndex} className={cell === \" \" ? \"cell empty\" : \"cell\"}>{cell}</div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div className=\"tray\">{tray}</div>\n      <div className=\"message\">{message}</div>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"app\")\n);\n","import { createState } from \"./state\";\nimport { createDictionary } from \"./dictionary\";\n\nclass Solver {\n  constructor() {\n    this.boardStates = new Map();\n    this.dictionary = createDictionary();\n    this.running = false;\n    \n    this.dictionary.onReady(() => {\n      this.readyCallback();\n    });\n  }\n\n  getPossibleNextStates(boardState) {\n    const tray = boardState.getTray();\n    const segments = boardState.getSegments();\n    const possiblePlacements = this.dictionary.getPossiblePlacements(tray, segments);\n    const possibleNextStates = new Set();\n    possiblePlacements.forEach((possiblePlacement) => {\n      const stateAfterPlacement = boardState.getStateAfterPlacement(possiblePlacement, this.dictionary);\n      if (stateAfterPlacement) {\n        possibleNextStates.add(stateAfterPlacement);\n      }\n    });\n    return possibleNextStates;\n  }\n  \n  onReady(callback) {\n    this.readyCallback = callback;\n  }\n  \n  onUpdate(callback) {\n    this.updateCallback = callback;\n  }\n\n  update(message, boardState) {\n    const config = { message };\n    if (boardState) {\n      config.tray = boardState.getTray();\n      config.board = boardState.getBoard();\n    } else {\n      config.tray = \"\";\n      config.board = [[]];\n    }\n    this.updateCallback(config);\n  }\n\n  solve(tray, blacklist) {\n    const emptyBoard = createState(tray);\n    const possibleNextStates = this.getPossibleNextStates(emptyBoard);\n    this.boardStates.clear();\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(iteration.toString(), possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n      this.running = Symbol();\n      this.tryBoardState(this.running, \"1\");\n    } else {\n      this.running = false;\n      this.update(\"No solutions possible!\", emptyBoard);\n    }\n  }\n\n  tryBoardState(running, key) {\n    if (this.running !== false && this.running !== running) {\n      return;\n    }\n\n    if (!this.boardStates.has(key)) {\n      const splitKey = key.split(\":\");\n      const splitKeyLen = splitKey.length;\n      if (splitKeyLen < 2) {\n        this.running = false;\n        this.update(\"No solutions possible!\");\n        return;\n      }\n      splitKey[splitKeyLen - 2] = parseInt(splitKey[splitKeyLen - 2]) + 1;\n      splitKey[splitKeyLen - 1] = 0;\n      this.tryBoardState(running, splitKey.join(\":\"));\n      return;\n    }\n\n    const boardState = this.boardStates.get(key);\n    const possibleNextStates = this.getPossibleNextStates(boardState);\n    boardState.setPossibleNextStates(possibleNextStates);\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(`${key}:${iteration.toString()}`, possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n\n      const splitKey = key.split(\":\");\n      const lastIndex = splitKey.length - 1;\n      splitKey[lastIndex] = parseInt(splitKey[lastIndex]) + 1;\n      this.tryBoardState(running, splitKey.join(\":\"));\n    }\n  }\n}\n\nexport const createSolver = () => new Solver();\n"],"sourceRoot":""}