{"version":3,"sources":["state.js","trie.js","dictionary.js","solver.js","index.js"],"names":["State","tray","board","columns","this","Map","numRows","Math","max","keys","numColumns","Array","fill","map","_","rowIndex","row","get","rowColumns","forEach","col","colIndex","dictionary","down","word","boardClone","columnsClone","trayClone","error","split","letter","index","originalValue","replace","set","colPlusIndex","Trie","trie","Dictionary","getMap","placements","rowSegments","colSegments","Set","getWordsFromTray","key","length","has","slice","str","chars","push","Solver","boardStates","running","boardState","possiblePlacements","getPossiblePlacements","getTray","getRowSegments","getColSegments","possibleNextStates","possiblePlacement","stateAfterPlacement","getStateAfterPlacement","add","callback","updateCallback","message","config","getBoard","blacklist","emptyBoard","createState","getPossibleNextStates","clear","size","iteration","solution","possibleNextState","isSolution","toString","update","Symbol","tryBoardState","splitKey","splitKeyLen","parseInt","join","setPossibleNextStates","lastIndex","App","useState","setBlacklist","setBoard","letters","setLetters","setMessage","setTray","solver","onUpdate","class","type","placeholder","value","onInput","e","newLetters","target","toLowerCase","solve","newBlacklist","cell","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.dca601fa.chunk.js","sourcesContent":["class State {\n  constructor(tray, board, columns) {\n    this.board = board || new Map();\n    this.columns = columns || 1;\n    this.tray = tray;\n  }\n\n  getBoard() {\n    const numRows = Math.max(...this.board.keys());\n    let numColumns = 0;\n    return Array(numRows)\n      .fill(true)\n      .map((_, rowIndex) => {\n        const row = this.board.get(rowIndex + 1);\n        if (row) {\n          const rowColumns = Math.max(numColumns, ...row.keys());\n          if (rowColumns > numColumns) {\n            numColumns = rowColumns;\n          }\n          const columns = Array(numColumns).fill(\" \");\n          row.forEach((col, colIndex) => {\n            columns[colIndex - 1] = col;\n          });\n          return columns;\n        } else {\n          return Array(numColumns).fill(\" \");\n        }\n      });\n  }\n\n  getColSegments() {\n    /*\n    return something like [{\n      col index,\n      row where `tiles` starts,\n      how many blank rows up (or 0 for no blockers),\n      how many blank rows down (or 0 for no blockers),\n      tiles: \"c-t\"\n    }, ...]\n    */\n  }\n\n  getRowSegments() {\n    /*\n    return something like [{\n      row index,\n      col where `tiles` starts,\n      how many blank cols left (or 0 for no blockers),\n      how many blank cols right (or 0 for no blockers),\n      tiles: \"c-t\"\n    }, ...]\n    */\n  }\n\n  getStateAfterPlacement({ row, col, down, word }, dictionary) {\n    const boardClone = this.board; // TODO: create a deep clone\n    let columnsClone = this.columns;\n    let trayClone = this.tray;\n    let error = false;\n    // TODO: handle negative row and col values\n    // TODO: add rows as needed to fit \"down\" words\n    if (down) {\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const originalValue = row.get(col);\n        const row = boardClone.get(row + index);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          // TODO: check the whole row using `dictionary.isAWord` to make sure we aren't creating any invalid words\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        row.set(col, letter);\n      });\n    } else {\n      const row = boardClone.get(row);\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const colPlusIndex = col + index;\n        const originalValue = row.get(colPlusIndex);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          // TODO: check the whole column using `dictionary.isAWord` to make sure we aren't creating any invalid words\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        row.set(colPlusIndex, letter);\n        if (colPlusIndex > columnsClone) {\n          columnsClone = colPlusIndex;\n        }\n      });\n    }\n    if (error) {\n      return false;\n    }\n    return new State(trayClone, boardClone, columnsClone);\n  }\n\n  getTray() {\n    return this.tray;\n  }\n\n  isSolution() {\n    return !this.tray;\n  }\n}\n\nexport const createState = (tray) => new State(tray);\n","class Trie {\n  constructor() {\n    const compressed = \"TODO: compressed trie\";\n    // TODO: uncompress `compressed`\n    // to get array of words: Object.keys(efrt.unpack(packd));\n    this.trie = new Map();\n    // TODO: populate `this.trie`\n  }\n\n  getMap() {\n    return this.trie;\n  }\n}\n\nexport const createTrie = () => new Trie();\n","import { createTrie } from \"./trie\";\n\nclass Dictionary {\n  constructor() {\n    const trie = createTrie();\n    this.trie = trie.getMap();\n  }\n\n  getPossiblePlacements({ tray, rowSegments, colSegments }) {\n    const placements = new Set();\n    const words = this.getWordsFromTray(tray);\n    // TODO: for each segment, match a regex against `words`\n    // TODO: for each matching word, create a \"placement\" object and add it to `placements`\n    return placements;\n  }\n\n  getWordsFromTray(tray) {\n    // TODO\n  }\n\n  has(trie, key) {\n    return !!trie && (key.length > 1 ? this.has(trie.get(key[0]), key.slice(1)) : trie.has(key));\n  }\n\n  isAWord(str) {\n    const chars = str.split(\"\");\n    chars.push(\"_\");\n    return this.has(this.trie, chars);\n  }\n}\n\nexport const createDictionary = () => new Dictionary();\n","import { createState } from \"./state\";\nimport { createDictionary } from \"./dictionary\";\n\nclass Solver {\n  constructor() {\n    this.boardStates = new Map();\n    this.dictionary = createDictionary();\n    this.running = false;\n  }\n\n  getPossibleNextStates(boardState) {\n    const possiblePlacements = this.dictionary.getPossiblePlacements({\n      tray: boardState.getTray(),\n      rowSegments: boardState.getRowSegments(),\n      colSegments: boardState.getColSegments(),\n    });\n    const possibleNextStates = new Set();\n    possiblePlacements.forEach((possiblePlacement) => {\n      const stateAfterPlacement = boardState.getStateAfterPlacement(possiblePlacement, this.dictionary);\n      if (stateAfterPlacement) {\n        possibleNextStates.add(stateAfterPlacement);\n      }\n    });\n    return possibleNextStates;\n  }\n\n  onUpdate(callback) {\n    this.updateCallback = callback;\n  }\n\n  update(message, boardState) {\n    const config = { message };\n    if (boardState) {\n      config.tray = boardState.getTray();\n      config.board = boardState.getBoard();\n    } else {\n      config.tray = \"\";\n      config.board = [[]];\n    }\n    this.updateCallback(config);\n  }\n\n  solve(tray, blacklist) {\n    const emptyBoard = createState(tray);\n    const possibleNextStates = this.getPossibleNextStates(emptyBoard);\n    this.boardStates.clear();\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(iteration.toString(), possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n      this.running = Symbol();\n      this.tryBoardState(this.running, \"1\");\n    } else {\n      this.running = false;\n      this.update(\"No solutions possible!\", emptyBoard);\n    }\n  }\n\n  tryBoardState(running, key) {\n    if (this.running !== false && this.running !== running) {\n      return;\n    }\n\n    if (!this.boardStates.has(key)) {\n      const splitKey = key.split(\":\");\n      const splitKeyLen = splitKey.length;\n      if (splitKeyLen < 2) {\n        this.running = false;\n        this.update(\"No solutions possible!\");\n        return;\n      }\n      splitKey[splitKeyLen - 2] = parseInt(splitKey[splitKeyLen - 2]) + 1;\n      splitKey[splitKeyLen - 1] = 0;\n      this.tryBoardState(running, splitKey.join(\":\"));\n      return;\n    }\n\n    const boardState = this.boardStates.get(key);\n    const possibleNextStates = this.getPossibleNextStates(boardState);\n    boardState.setPossibleNextStates(possibleNextStates);\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(`${key}:${iteration.toString()}`, possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n\n      const splitKey = key.split(\":\");\n      const lastIndex = splitKey.length - 1;\n      splitKey[lastIndex] = parseInt(splitKey[lastIndex]) + 1;\n      this.tryBoardState(running, splitKey.join(\":\"));\n    }\n  }\n}\n\nexport const createSolver = () => new Solver();\n","import \"./styles.css\";\nimport React, { useState } from \"React\";\nimport ReactDOM from \"react-dom\";\nimport { createSolver } from \"./solver\";\n\nconst App = () => {\n  const [blacklist, setBlacklist] = useState(\"\");\n  const [board, setBoard] = useState([[]]);\n  const [letters, setLetters] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [tray, setTray] = useState(\"\");\n\n  const solver = createSolver();\n\n  const updateBlacklistAndSolve = (e) => {\n    const newBlacklist = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setBlacklist(newBlacklist);\n    solver.solve(letters, newBlacklist);\n  };\n  const updateLettersAndSolve = (e) => {\n    const newLetters = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setLetters(newLetters);\n    solver.solve(newLetters, blacklist);\n  };\n\n  solver.onUpdate(({ tray, message, board }) => {\n    setTray(tray);\n    setMessage(message);\n    setBoard(board);\n  });\n\n  return (\n    <div>\n      <div class=\"header\">\n        <h1>Bananagrams Solver</h1>\n      </div>\n      <div class=\"letterbox\">\n        <input type=\"text\" placeholder=\"yourtileshere\" value={letters} onInput={updateLettersAndSolve} />\n      </div>\n      <div class=\"controls\">\n        <div>\n          <label>Word Blacklist</label>\n          <small>(Comma-separated)</small>\n        </div>\n        <div>\n          <input type=\"text\" value={blacklist} onInput={updateBlacklistAndSolve} />\n        </div>\n      </div>\n      <div class=\"boardbox\">\n        <div class=\"board\">\n          {board.map((row) => (\n            <div class=\"row\">\n              {row.map((cell) => (\n                <div class=\"cell\" class={cell === \" \" ? \"empty\" : \"\"}>\n                  {cell}\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div class=\"tray\">{tray}</div>\n      <div class=\"message\">{message}</div>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"app\")\n);\n"],"sourceRoot":""}