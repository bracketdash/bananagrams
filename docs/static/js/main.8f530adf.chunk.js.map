{"version":3,"sources":["state.js","assets/words.txt","dictionary.js","solver.js","index.js"],"names":["State","tray","board","columns","this","Map","numRows","Math","max","keys","numColumns","Array","fill","map","_","rowIndex","row","get","rowColumns","forEach","col","colIndex","dictionary","down","word","boardClone","rowCols","rowKey","cols","colKey","set","columnsClone","trayClone","error","split","letter","index","tileRow","originalValue","lastSpaceWasEmpty","cell","result","trim","rowWord","isAWord","replace","colPlusIndex","colWord","Dictionary","nodesArr","words","pattern","RegExp","syms","symCount","node","match","exec","fromAlphaCode","nodes","slice","length","val","trie","can","temp","includes","s","seq","undefined","indexOf","n","places","range","pow","i","d","charCodeAt","segments","patternMap","placements","Set","getWordsFromTray","segment","add","test","crawl","pref","canBeMadeFromTray","matches","str","ref","have","indexFromRef","key","has","dnode","chars","push","Solver","boardStates","running","boardState","getTray","getSegments","possiblePlacements","getPossiblePlacements","possibleNextStates","possiblePlacement","stateAfterPlacement","getStateAfterPlacement","callback","updateCallback","message","config","getBoard","blacklist","emptyBoard","createState","getPossibleNextStates","clear","size","iteration","solution","possibleNextState","isSolution","toString","update","Symbol","tryBoardState","splitKey","splitKeyLen","parseInt","join","setPossibleNextStates","lastIndex","App","useState","setBlacklist","setBoard","letters","setLetters","setMessage","setTray","solver","onUpdate","className","type","placeholder","value","onInput","e","newLetters","target","toLowerCase","solve","newBlacklist","cellIndex","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8f530adf.chunk.js","sourcesContent":["class State {\n  constructor(tray, board, columns) {\n    this.board = board || new Map();\n    this.columns = columns || 1;\n    this.tray = tray;\n  }\n\n  getBoard() {\n    const numRows = Math.max(...this.board.keys());\n    let numColumns = 0;\n    return Array(numRows)\n      .fill(true)\n      .map((_, rowIndex) => {\n        const row = this.board.get(rowIndex + 1);\n        if (row) {\n          const rowColumns = Math.max(numColumns, ...row.keys());\n          if (rowColumns > numColumns) {\n            numColumns = rowColumns;\n          }\n          const columns = Array(numColumns).fill(\" \");\n          row.forEach((col, colIndex) => {\n            columns[colIndex - 1] = col;\n          });\n          return columns;\n        } else {\n          return Array(numColumns).fill(\" \");\n        }\n      });\n  }\n\n  getSegments() {\n    /* TODO: return something like...\n    Set([{\n      row: the row index of the first tile in `tiles`,\n      col: the column index of the first file in `tiles`,\n      down: whether the segment is part of a row or column (down is true if column),\n      tiles: the tiles in this segment (\"-\" for whitespace),\n      pre: how much whitespace before the tiles is available,\n      post: how much whitespace after the tiles is available,\n      pattern: a regex pattern to make searching word sets fast\n    }])\n    */\n  }\n\n  getStateAfterPlacement({ row, col, down, word }, dictionary) {\n    const boardClone = new Map();\n    this.board.forEach((rowCols, rowKey) => {\n      const cols = new Map();\n      rowCols.forEach((col, colKey) => {\n        cols.set(colKey, col);\n      });\n      boardClone.set(rowKey, cols);\n    });\n    let columnsClone = this.columns;\n    let trayClone = this.tray;\n    let error = false;\n\n    // TODO: handle negative row and col values\n    // TODO: add rows as needed to fit \"down\" words\n\n    if (down) {\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const tileRow = boardClone.get(row + index);\n        const originalValue = tileRow.get(col);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          let lastSpaceWasEmpty = false;\n          const rowWords = Array(this.columns)\n            .fill(true)\n            .map((_, index) => {\n              const cell = tileRow.get(index + 1);\n              if (cell) {\n                if (lastSpaceWasEmpty) {\n                  lastSpaceWasEmpty = false;\n                }\n                return cell;\n              }\n\n              let result = \" \";\n              if (lastSpaceWasEmpty) {\n                result = \"\";\n              } else {\n                lastSpaceWasEmpty = true;\n              }\n              return result;\n            })\n            .trim()\n            .split(\" \");\n          rowWords.forEach((rowWord) => {\n            if (!dictionary.isAWord(rowWord)) {\n              error = true;\n            }\n          });\n          if (error) {\n            return;\n          }\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        tileRow.set(col, letter);\n      });\n    } else {\n      const tileRow = boardClone.get(row);\n      word.split(\"\").forEach((letter, index) => {\n        if (error) {\n          return;\n        }\n        const colPlusIndex = col + index;\n        const originalValue = tileRow.get(colPlusIndex);\n        if (originalValue) {\n          if (originalValue !== letter) {\n            error = true;\n            return;\n          }\n        } else {\n          const numRows = Math.max(...this.board.keys());\n          let lastSpaceWasEmpty = false;\n          const colWords = Array(numRows)\n            .fill(true)\n            .map((_, index) => {\n              const tileRow = this.board.get(index + 1);\n              const cell = tileRow.get(colPlusIndex);\n              if (cell) {\n                if (lastSpaceWasEmpty) {\n                  lastSpaceWasEmpty = false;\n                }\n                return cell;\n              }\n\n              let result = \" \";\n              if (lastSpaceWasEmpty) {\n                result = \"\";\n              } else {\n                lastSpaceWasEmpty = true;\n              }\n              return result;\n            })\n            .trim()\n            .split(\" \");\n          colWords.forEach((colWord) => {\n            if (!dictionary.isAWord(colWord)) {\n              error = true;\n            }\n          });\n          if (error) {\n            return;\n          }\n          trayClone = trayClone.replace(letter, \"\");\n        }\n        tileRow.set(colPlusIndex, letter);\n        if (colPlusIndex > columnsClone) {\n          columnsClone = colPlusIndex;\n        }\n      });\n    }\n    if (error) {\n      return false;\n    }\n    return new State(trayClone, boardClone, columnsClone);\n  }\n\n  getTray() {\n    return this.tray;\n  }\n\n  isSolution() {\n    return !this.tray;\n  }\n}\n\nexport const createState = (tray) => new State(tray);\n","export default __webpack_public_path__ + \"static/media/words.93cee45c.txt\";","import words from \"./assets/words.txt\";\n\nclass Dictionary {\n  constructor() {\n    const nodesArr = words.split(\";\");\n    const pattern = new RegExp(\"([0-9A-Z]+):([0-9A-Z]+)\");\n    const syms = new Map();\n    let symCount = 0;\n\n    nodesArr.forEach((node, index) => {\n      const match = pattern.exec(node);\n      if (!match) {\n        symCount = index;\n        return;\n      }\n      syms.set(this.fromAlphaCode(match[1]), this.fromAlphaCode(match[2]));\n    });\n\n    const nodes = new Map(\n      nodesArr.slice(symCount, nodesArr.length).map((val, index) => {\n        return [index, val];\n      })\n    );\n\n    this.trie = { nodes, syms, symCount };\n  }\n\n  canBeMadeFromTray(tray, word) {\n    let can = true;\n    let temp = tray;\n    word.split(\"\").forEach((letter) => {\n      if (temp.includes(letter)) {\n        temp = temp.replace(letter, \"\");\n      } else {\n        can = false;\n      }\n    });\n    return can;\n  }\n\n  fromAlphaCode(s) {\n    const seq = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    if (seq[s] !== undefined) {\n      return seq.indexOf(s);\n    }\n\n    const BASE = 36;\n    let n = 0;\n    let places = 1;\n    let range = BASE;\n    let pow = 1;\n\n    while (places < s.length) {\n      n += range;\n      places++;\n      range *= BASE;\n    }\n\n    for (let i = s.length - 1; i >= 0; i--) {\n      let d = s.charCodeAt(i) - 48;\n      if (d > 10) {\n        d -= 7;\n      }\n      n += d * pow;\n      pow *= BASE;\n    }\n    return n;\n  }\n\n  getPossiblePlacements(tray, segments) {\n    const patternMap = new Map();\n    const placements = new Set();\n    const words = this.getWordsFromTray(tray);\n\n    segments.forEach((segment) => {\n      const segments = patternMap.get(segment.pattern);\n      if (!segments) {\n        patternMap.set(segment.pattern, new Set([segment]));\n      } else {\n        segments.add(segment);\n      }\n    });\n\n    words.forEach((word) => {\n      const patterns = patternMap.keys();\n      patterns.forEach((pattern) => {\n        if (pattern.test(word)) {\n          const segments = patternMap.get(pattern);\n          segments.forEach((segment) => {\n            // TODO: find possible placements for it within the segment\n            // TODO: placements.add({ row, col, down, word });\n          });\n        }\n      });\n    });\n\n    return placements;\n  }\n\n  getWordsFromTray(tray) {\n    const words = new Set();\n    const crawl = (index, pref) => {\n      let node = this.trie.nodes.get(index);\n      if (node[0] === \"!\") {\n        if (this.canBeMadeFromTray(tray, pref)) {\n          words.add(pref);\n        }\n        node = node.slice(1);\n      }\n      const matches = node.split(/([A-Z0-9,]+)/g);\n      for (let i = 0; i < matches.length; i += 2) {\n        const str = matches[i];\n        if (!str) {\n          continue;\n        }\n        const ref = matches[i + 1];\n        const have = pref + str;\n        if (ref === \",\" || ref === undefined) {\n          if (this.canBeMadeFromTray(tray, have)) {\n            words.add(have);\n          }\n          continue;\n        }\n        crawl(this.indexFromRef(ref, index), have);\n      }\n    };\n    crawl(0, \"\");\n    return words;\n  }\n\n  has(trie, key) {\n    return !!trie && (key.length > 1 ? this.has(trie.get(key[0]), key.slice(1)) : trie.has(key));\n  }\n\n  indexFromRef(ref, index) {\n    const dnode = this.fromAlphaCode(ref);\n    if (dnode < this.trie.symCount) {\n      return this.trie.syms.get(dnode);\n    }\n    return index + dnode + 1 - this.trie.symCount;\n  }\n\n  isAWord(str) {\n    const chars = str.split(\"\");\n    chars.push(\"_\");\n    return this.has(this.trie, chars);\n  }\n}\n\nexport const createDictionary = () => new Dictionary();\n","import { createState } from \"./state\";\nimport { createDictionary } from \"./dictionary\";\n\nclass Solver {\n  constructor() {\n    this.boardStates = new Map();\n    this.dictionary = createDictionary();\n    this.running = false;\n  }\n\n  getPossibleNextStates(boardState) {\n    const tray = boardState.getTray();\n    const segments = boardState.getSegments();\n    const possiblePlacements = this.dictionary.getPossiblePlacements(tray, segments);\n    const possibleNextStates = new Set();\n    possiblePlacements.forEach((possiblePlacement) => {\n      const stateAfterPlacement = boardState.getStateAfterPlacement(possiblePlacement, this.dictionary);\n      if (stateAfterPlacement) {\n        possibleNextStates.add(stateAfterPlacement);\n      }\n    });\n    return possibleNextStates;\n  }\n\n  onUpdate(callback) {\n    this.updateCallback = callback;\n  }\n\n  update(message, boardState) {\n    const config = { message };\n    if (boardState) {\n      config.tray = boardState.getTray();\n      config.board = boardState.getBoard();\n    } else {\n      config.tray = \"\";\n      config.board = [[]];\n    }\n    this.updateCallback(config);\n  }\n\n  solve(tray, blacklist) {\n    const emptyBoard = createState(tray);\n    const possibleNextStates = this.getPossibleNextStates(emptyBoard);\n    this.boardStates.clear();\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(iteration.toString(), possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n      this.running = Symbol();\n      this.tryBoardState(this.running, \"1\");\n    } else {\n      this.running = false;\n      this.update(\"No solutions possible!\", emptyBoard);\n    }\n  }\n\n  tryBoardState(running, key) {\n    if (this.running !== false && this.running !== running) {\n      return;\n    }\n\n    if (!this.boardStates.has(key)) {\n      const splitKey = key.split(\":\");\n      const splitKeyLen = splitKey.length;\n      if (splitKeyLen < 2) {\n        this.running = false;\n        this.update(\"No solutions possible!\");\n        return;\n      }\n      splitKey[splitKeyLen - 2] = parseInt(splitKey[splitKeyLen - 2]) + 1;\n      splitKey[splitKeyLen - 1] = 0;\n      this.tryBoardState(running, splitKey.join(\":\"));\n      return;\n    }\n\n    const boardState = this.boardStates.get(key);\n    const possibleNextStates = this.getPossibleNextStates(boardState);\n    boardState.setPossibleNextStates(possibleNextStates);\n    if (possibleNextStates.size) {\n      let iteration = 1;\n      let solution = false;\n      possibleNextStates.forEach((possibleNextState) => {\n        if (solution) {\n          return;\n        }\n        if (possibleNextState.isSolution()) {\n          solution = possibleNextState;\n          return;\n        }\n        this.boardStates.set(`${key}:${iteration.toString()}`, possibleNextState);\n        iteration++;\n      });\n      if (solution) {\n        this.running = false;\n        this.update(\"Solution found!\", solution);\n        return;\n      }\n\n      const splitKey = key.split(\":\");\n      const lastIndex = splitKey.length - 1;\n      splitKey[lastIndex] = parseInt(splitKey[lastIndex]) + 1;\n      this.tryBoardState(running, splitKey.join(\":\"));\n    }\n  }\n}\n\nexport const createSolver = () => new Solver();\n","import \"./assets/styles.css\";\nimport React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createSolver } from \"./solver\";\n\nconst App = () => {\n  const [blacklist, setBlacklist] = useState(\"\");\n  const [board, setBoard] = useState([[]]);\n  const [letters, setLetters] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [tray, setTray] = useState(\"\");\n\n  const solver = createSolver();\n\n  const updateBlacklistAndSolve = (e) => {\n    const newBlacklist = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setBlacklist(newBlacklist);\n    solver.solve(letters, newBlacklist);\n  };\n  const updateLettersAndSolve = (e) => {\n    const newLetters = e.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setLetters(newLetters);\n    solver.solve(newLetters, blacklist);\n  };\n\n  solver.onUpdate(({ tray, message, board }) => {\n    setTray(tray);\n    setMessage(message);\n    setBoard(board);\n  });\n\n  return (\n    <div>\n      <div className=\"header\">\n        <h1>Bananagrams Solver</h1>\n      </div>\n      <div className=\"letterbox\">\n        <input type=\"text\" placeholder=\"yourtileshere\" value={letters} onInput={updateLettersAndSolve} />\n      </div>\n      <div className=\"controls\">\n        <div>\n          <label>Word Blacklist</label>\n          <small>(Comma-separated)</small>\n        </div>\n        <div>\n          <input type=\"text\" value={blacklist} onInput={updateBlacklistAndSolve} />\n        </div>\n      </div>\n      <div className=\"boardbox\">\n        <div className=\"board\">\n          {board.map((row, rowIndex) => (\n            <div key={rowIndex} className=\"row\">\n              {row.map((cell, cellIndex) => (\n                <div key={cellIndex} className={cell === \" \" ? \"cell empty\" : \"cell\"}>{cell}</div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div className=\"tray\">{tray}</div>\n      <div className=\"message\">{message}</div>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"app\")\n);\n"],"sourceRoot":""}